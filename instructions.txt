## Azure Configuration for Stripe Integration (Multi-Environment Strategy)

This document outlines the principles and specific setup for configuring Stripe integration variables across different Azure environments (dev1, stg, prod) for the AI Detector application, using Azure Key Vault and Azure Container Apps.

### Principles:

1.  **Centralized Secret Management:** All sensitive information (API keys, secrets) is stored securely in Azure Key Vault. This provides a single source of truth for secrets, enhances security, and allows for auditing.
2.  **Environment-Specific Secrets:** For each environment (dev1, stg, prod), distinct secrets are created in Key Vault (e.g., `stripe-secret-dev1`, `stripe-secret-stg`). This ensures that each environment uses its own isolated set of credentials and configurations.
3.  **Container App Secret Referencing:** Azure Container Apps do not store the actual secret values directly. Instead, they store *references* (aliases) to the secrets held in Azure Key Vault. This maintains a separation of concerns and leverages Key Vault's security.
4.  **Environment Variable Mapping:** Within each Container App (for both backend and frontend), these Container App secret references (aliases) are mapped to specific environment variable names that the application code expects (e.g., `STRIPE_SECRET_KEY`, `VITE_STRIPE_PUBLISHABLE_KEY`).
5.  **Application Code Agnosticism:** The application code (FastAPI backend, Vite frontend) remains environment-agnostic. It reads configuration from standard environment variable names. The Azure infrastructure handles injecting the correct values for the specific environment it's running in.
6.  **Managed Identity:** Container Apps should use Managed Identities with appropriate "Get Secret" permissions on the Azure Key Vault to securely access the referenced secrets.

### Configuration for `dev1` Environment:

**1. Azure Key Vault (`kv-sdt-uks-aid-dev1`):**

The following secrets have been created/updated in this Key Vault specifically for the `dev1` environment:

*   **`stripe-secret-dev1`**:
    *   **Value:** The Stripe **Secret Key** for `dev1` (e.g., `sk_test_...` or `sk_live_...`). (Actual value confirmed to be at version `...ca1cac48c0fb4c30a8e5c3da1a450438`).
    *   **Purpose:** Used by the backend to authenticate API calls to Stripe.
*   **`stripe-webhook-secret-dev1`**:
    *   **Value:** The Stripe **Webhook Signing Secret** for `dev1` (e.g., `whsec_...`).
    *   **Purpose:** Used by the backend to verify incoming webhook events from Stripe.
*   **`stripe-pro-plan-price-id-dev1`**:
    *   **Value:** The Stripe **Price ID** for the "Pro" plan in `dev1` (e.g., `price_...`).
    *   **Purpose:** Used by the backend to create Stripe Checkout Sessions.
*   **`vite-stripe-publishable-key-dev1`**:
    *   **Value:** The Stripe **Publishable Key** for `dev1` (e.g., `pk_test_...` or `pk_live_...`).
    *   **Purpose:** Used by the frontend (Stripe.js) for client-side operations.

**2. Backend Container App (`ca-sdt-uks-aid-dev1`):**

*   **Container App Secrets (Aliases Referencing Key Vault):**
    *   Alias: `stripe-secret-key` -> Referencing Key Vault secret `stripe-secret-dev1` (specifically URL: `https://kv-sdt-uks-aid-dev1.vault.azure.net/secrets/stripe-secret-dev1/ca1cac48c0fb4c30a8e5c3da1a450438`).
    *   Alias: `backend-kvref-stripe-webhook` -> Referencing Key Vault secret `stripe-webhook-secret-dev1`.
    *   Alias: `backend-kvref-stripe-price-id` -> Referencing Key Vault secret `stripe-pro-plan-price-id-dev1`.
*   **Environment Variables (Mapped in Container Revision):**
    *   `STRIPE_SECRET_KEY` -> Mapped from Container App secret alias `stripe-secret-key`.
    *   `STRIPE_WEBHOOK_SECRET` -> Mapped from Container App secret alias `backend-kvref-stripe-webhook`.
    *   `STRIPE_PRO_PLAN_PRICE_ID` -> Mapped from Container App secret alias `backend-kvref-stripe-price-id`.
    *   `FRONTEND_URL` -> Manual entry: `https://gray-mud-0fe5b3703.6.azurestaticapps.net` (Confirmed as correct for `dev1` frontend).

**3. Frontend Container App (Name to be confirmed, e.g., `ca-sdt-uks-aid-frontend-dev1`):**

*   **Container App Secrets (Aliases Referencing Key Vault):**
    *   Alias: (e.g., `frontend-stripe-publishable-key-ref`) -> Referencing Key Vault secret `vite-stripe-publishable-key-dev1`.
*   **Environment Variables (Mapped in Container Revision):**
    *   `VITE_STRIPE_PUBLISHABLE_KEY` -> Mapped from Container App secret alias (e.g., `frontend-stripe-publishable-key-ref`).
    *   `VITE_API_BASE_URL` -> Manual entry: The public HTTPS URL of the `dev1` backend container app (i.e., `ca-sdt-uks-aid-dev1`).

### To-Do & Future Considerations:

1.  **Verify Values:** Double-check that the actual secret values for `dev1` (Stripe keys, IDs, webhook secret) are correctly populated in the corresponding Key Vault secrets (`stripe-secret-dev1`, `stripe-webhook-secret-dev1`, etc.). (Stripe Secret Key value for `stripe-secret-dev1` confirmed to be at the specified version).
2.  **Cleanup Placeholders in Key Vault:**
    *   Review the generic `stripe-secret-key` (without `-dev1` suffix) in Key Vault `kv-sdt-uks-aid-dev1`. If `stripe-secret-dev1` is now the definitive secret for the dev1 Stripe Secret Key, and the generic one was a placeholder, consider deleting the generic `stripe-secret-key` to avoid confusion. Confirm it's not referenced by any Container App secret before deleting.
3.  **Configuration for `stg` and `prod` Environments:**
    *   **Key Vault:** Create new secrets in Key Vault for `stg` and `prod` with appropriate suffixes (e.g., `stripe-secret-stg`, `stripe-webhook-secret-prod`). Populate them with the respective Stripe keys/IDs for those environments.
    *   **Container Apps:** For the `stg` and `prod` Container Apps (both backend and frontend), configure their "Secrets" sections to reference these new `stg` and `prod` Key Vault secrets, using appropriate alias names within each Container App.
    *   **Environment Variables:** Update the environment variable mappings in the `stg` and `prod` Container App revisions. This includes `FRONTEND_URL` (for backend) and `VITE_API_BASE_URL` (for frontend) to point to the correct URLs for each environment.
4.  **Stripe Dashboard Webhook URLs:** Ensure that for each environment (dev1, stg, prod), the Stripe Dashboard has a webhook endpoint configured with the correct public URL of the respective backend container app (e.g., `https://[backend-dev1-url]/webhooks/stripe`, `https://[backend-stg-url]/webhooks/stripe`). Each of these Stripe webhook configurations will have its own Webhook Signing Secret, which corresponds to the `STRIPE_WEBHOOK_SECRET` value stored in Key Vault for that environment.
5.  **Managed Identity Permissions:** Confirm that the Managed Identities assigned to the backend and frontend Container Apps have the necessary "Get Secret" permissions on the Azure Key Vault (`kv-sdt-uks-aid-dev1`). This is usually configured under Key Vault > Access policies or Access control (IAM) depending on the permission model used (Vault access policy or Azure RBAC).


## Understanding Identity, Subscription, and RBAC Flow in the Application

This document outlines how different identifiers (`kinde_id`, internal `teacher_id`, Stripe IDs) are used within the application to manage user identity, link to third-party services like Kinde (for authentication) and Stripe (for payments), and implement Role-Based Access Control (RBAC). The `Teacher` model is the central entity where these identifiers and related statuses converge.

### 1. Core Identifiers

#### a. Kinde ID (`kinde_id`)
*   **Source**: Provided by the Kinde Authentication service upon successful user login. It's typically part of the JWT (JSON Web Token) claims.
*   **Nature**: A string unique to each user within your Kinde instance.
*   **Role in Application**:
    *   Acts as the primary link between the external authentication system (Kinde) and an application user record (`Teacher` model).
    *   Used immediately after authentication to look up or create the corresponding `Teacher` record in the application's database.
*   **Storage**: Stored as a mandatory, indexed field on the `Teacher` model.

#### b. Internal Teacher ID (`id` or `_id`)
*   **Source**: Generated by the application's database (MongoDB) when a new `Teacher` record is created. This is typically a UUID or MongoDB ObjectId. In Pydantic models, it's often aliased from `_id` (database field name) to `id` (model field name).
*   **Nature**: A unique identifier for each teacher record *within the application's internal database*.
*   **Role in Application**:
    *   **Primary Internal Key**: Serves as the stable, internal primary key for the `Teacher` collection.
    *   **Database Relationships**: Used as a foreign key in other database collections to establish relationships (e.g., a `Document` or `ClassGroup` created by a teacher would store this `teacher_id` to signify ownership or association).
    *   **RBAC Core**: Central to many RBAC checks, especially for resource ownership and linking actions to a specific, verified internal user account.
    *   **Internal Logging & Auditing**: Provides a consistent internal reference to a user.
*   **Storage**: Stored as the `_id` field in the `teachers` MongoDB collection and represented as `id` in the `Teacher` Pydantic model.

### 2. Stripe Integration Identifiers

These IDs link a `Teacher` record to their financial and subscription details in Stripe.

#### a. Stripe Customer ID (`stripe_customer_id`)
*   **Source**: Generated by the Stripe API when a new customer object is created in Stripe for a teacher (typically when they first initiate a subscription).
*   **Nature**: A string unique to each customer in your Stripe account (e.g., `cus_xxxxxxxxxxxxxx`).
*   **Role in Application**:
    *   Links the application's `Teacher` record to the corresponding customer entity in Stripe.
    *   Essential for creating subscriptions, managing payment methods, and redirecting to the Stripe customer portal.
*   **Storage**: Stored as an optional, indexed field on the `Teacher` model.
*   **Linkage Detail**: When creating the Stripe Customer, metadata including the internal `teacher_id` (as `teacher_internal_id`) and `kinde_id` (as `teacher_kinde_id`) is passed to Stripe. This provides a robust reverse link from Stripe back to the application's user identifiers for auditing and reconciliation.

#### b. Stripe Subscription ID (`stripe_subscription_id`)
*   **Source**: Generated by the Stripe API when a teacher successfully subscribes to a plan (e.g., the "Pro" plan).
*   **Nature**: A string unique to each subscription in your Stripe account (e.g., `sub_xxxxxxxxxxxxxx`).
*   **Role in Application**:
    *   Identifies a specific active or past subscription for a teacher.
    *   Used by Stripe webhooks to refer to events related to that specific subscription (e.g., updates, renewals, cancellations).
*   **Storage**: Stored as an optional, indexed field on the `Teacher` model.

### 3. The `Teacher` Model: The Central Hub

The `Teacher` model (defined in `backend/app/models/teacher.py`) is pivotal. It aggregates these identifiers and other critical information:

*   **`id` (`_id`)**: The internal primary key (UUID).
*   **`kinde_id`**: The link to Kinde authentication.
*   **Profile Information**: `first_name`, `last_name`, `email`, `school_name`, etc.
*   **Role & Permissions Fields**:
    *   `role` (e.g., `TeacherRole.TEACHER`, `TeacherRole.ADMIN`)
    *   `is_administrator` (boolean)
    *   `is_active` (boolean)
*   **Stripe-Related Fields**:
    *   `stripe_customer_id`
    *   `stripe_subscription_id`
    *   `current_plan` (e.g., `SubscriptionPlan.FREE`, `SubscriptionPlan.PRO`) - *Crucial for RBAC feature gating.*
    *   `subscription_status` (e.g., `StripeSubscriptionStatus.ACTIVE`, `StripeSubscriptionStatus.CANCELED`)
    *   `current_period_end` (datetime for subscription validity)

### 4. Interplay and RBAC Flow

Here’s how these elements work together to enable RBAC:

1.  **Authentication and User Context Establishment**:
    *   A user logs in via Kinde.
    *   Kinde authenticates the user and issues a JWT containing their `kinde_id`.
    *   The application backend receives requests with this JWT. A dependency (e.g., `get_current_teacher`) validates the token and extracts the `kinde_id`.
    *   This `kinde_id` is used to query the `teachers` collection in MongoDB to retrieve the full `Teacher` object/document. This object now contains the internal `id` (`teacher_id`), Kinde details, Stripe details, roles, and subscription plan. This `Teacher` object becomes the "current user" context for the request.

2.  **RBAC Logic and Permission Checks**:
    Once the `Teacher` object is fetched, RBAC decisions are made based on its attributes:
    *   **Role-Based Access**:
        *   Checks like `if current_teacher.role == TeacherRole.ADMIN:` or `if current_teacher.is_administrator:` control access to administrative functionalities.
    *   **Subscription-Based Feature Gating**:
        *   Checks like `if current_teacher.current_plan == SubscriptionPlan.PRO:` determine if the user can access premium features. This is updated via Stripe webhooks ensuring it reflects the actual subscription status.
    *   **Resource Ownership and Access**:
        *   Many other models in the system (e.g., `Documents`, `ClassGroups`, `AssessmentTasks`) will have a field like `teacher_id` (or `owner_id`, etc.) that stores the `Teacher.id` (internal MongoDB `_id`) of the teacher who owns or is associated with that resource.
        *   When a teacher attempts to access or modify such a resource, RBAC logic will compare the `resource.teacher_id` with the `current_teacher.id`. Access is granted only if they match (or if the `current_teacher` is an administrator with override permissions).
    *   **Account Status**: `if current_teacher.is_active:` can prevent inactive users from accessing the system.

3.  **Stripe Webhooks and Data Synchronization**:
    *   Stripe sends webhooks to the application for events like `checkout.session.completed`, `invoice.paid`, `customer.subscription.updated/deleted`.
    *   These webhooks contain the `stripe_customer_id` and/or `stripe_subscription_id`.
    *   The application uses these Stripe IDs to find the corresponding `Teacher` record in its database.
    *   It then updates the teacher's `current_plan`, `subscription_status`, `current_period_end`, and `stripe_subscription_id` (if applicable) based on the webhook event.
    *   This ensures that the `Teacher` model in the application database always has an up-to-date reflection of the user's subscription status, which is then used for RBAC.

### 5. Conceptual Data Flow and Relationship Diagram




Database structure

-teachers: Manages all teacher user accounts, authentication (Kinde ID), and Stripe subscription plans (Free, Pro).

-documents: Tracks every uploaded file's metadata, including its processing status (Uploaded, Queued, Limit Exceeded, etc.) and character/word counts.

-results: Stores the AI-generated assessment scores and details for each processed document.

-assessment_tasks: A queue holding documents that are waiting to be processed by the AI assessment worker.

-assessment_deadletter: Archives tasks that failed repeatedly during AI assessment.

-batches: Organizes documents that were uploaded together in a single batch by a teacher.

-classgroups: Defines classrooms or groups created by teachers, linking teachers to their students.

-schools: Stores information about different educational institutions.

-students: Manages student profiles, linking them to their respective teachers.

-users: Appears to be an unused or deprecated collection, as its corresponding model file (user.py) is entirely commented out. Teacher-related user management is handled by the teachers collection.

# Document Status Process Flows (Frontend: DocumentsPage.jsx)

This document outlines the various statuses a document can have within the application, how each status is triggered, and the typical process flow involved.

## 1. `UPLOADED`

*   **Description:** This is the initial status of a document immediately after a successful upload.
*   **Triggered By:**
    *   A user successfully uploads one or more files using the single or bulk upload feature.
*   **Process Flow:**
    1.  **User Action:** Selects a file (or multiple files) and clicks the "Upload" button.
    2.  **Frontend (`performUpload`):** The selected file(s) are sent to the backend API endpoint (e.g., `/api/v1/documents/upload`).
    3.  **Backend:** The backend receives the file, creates a new document record in the database, and assigns it an initial status (which is recognized as `UPLOADED` by the frontend).
    4.  **Frontend (`fetchDocuments`):** After the upload attempt, the frontend refreshes its list of documents from the backend.
    5.  **UI Display:** The newly uploaded document(s) appear in the table with the status "UPLOADED". At this stage, actions like "Assess" are typically available.

## 2. `QUEUED`

*   **Description:** The document has been submitted for assessment and is waiting in a queue to be processed by a backend worker.
*   **Triggered By:**
    *   User clicks "Assess" on a document with status `UPLOADED`.
    *   User clicks "Retry" on a document with status `ERROR` or `LIMIT_EXCEEDED`.
    *   User clicks "Reprocess" on a document (the frontend optimistically updates the UI to `QUEUED` in this specific scenario before backend confirmation).
*   **Process Flow (e.g., via `handleAssess` or `handleReprocessDocument`):**
    1.  **User Action:** Clicks the "Assess", "Retry", or "Reprocess" button for a document.
    2.  **Frontend:**
        *   An API request is sent to the appropriate backend endpoint (e.g., `/documents/{id}/assess` or `/documents/{id}/reprocess`).
        *   The UI might show a temporary loading indicator on the action button.
    3.  **Backend:**
        *   The backend receives the request.
        *   It places the document into a processing queue and updates the document's status to `QUEUED` in the database.
    4.  **Frontend (`fetchDocuments`):** The frontend, either through a direct call after the action or via its polling mechanism, retrieves the updated list of documents.
    5.  **UI Display:** The document's status in the table changes to "QUEUED".

## 3. `PROCESSING`

*   **Description:** A backend worker has picked up the document from the queue and is actively analyzing it.
*   **Triggered By:**
    *   A backend assessment worker takes a document with the `QUEUED` status from the processing queue.
*   **Process Flow:**
    1.  **Backend:** An assessment worker dequeues a document.
    2.  **Backend:** The worker updates the document's status in the database to `PROCESSING`.
    3.  **Frontend (Polling):** The `useEffect` hook in `DocumentsPage.jsx` periodically calls `fetchDocuments(true)`, which fetches the latest document statuses.
    4.  **UI Display:** If the document's status has changed from `QUEUED` to `PROCESSING`, the UI updates to show "PROCESSING". A spinner icon is typically displayed, and a "Cancel" button becomes available.

## 4. `COMPLETED`

*   **Description:** The backend assessment worker has successfully finished processing and analyzing the document.
*   **Triggered By:**
    *   The backend worker successfully completes all analysis tasks for the document.
*   **Process Flow:**
    1.  **Backend:** The assessment worker finishes its tasks (e.g., calculates AI score, word count, character count).
    2.  **Backend:** The worker updates the document's status to `COMPLETED` in the database and saves the assessment results.
    3.  **Frontend (Polling & Results Fetch):**
        *   The polling mechanism (`fetchDocuments(true)`) retrieves the new `COMPLETED` status.
        *   The `fetchResultsForDocuments` function is then typically called to get the detailed assessment results (like the AI score) for this document if they aren't already present in the frontend's state.
    4.  **UI Display:** The document's status changes to "COMPLETED". The AI score is displayed, and the "View Report" action becomes the primary interaction.

## 5. `ERROR`

*   **Description:** An error occurred during the document's processing, or an ongoing assessment was successfully cancelled by the user.
*   **Triggered By:**
    *   **Backend Processing Failure:** The assessment worker encounters an unrecoverable issue while analyzing the document.
    *   **Successful User-Initiated Cancellation:** A user clicks "Cancel" for a `PROCESSING` document, and the backend confirms the cancellation was successful. The frontend then updates the status locally.
*   **Process Flow (Backend Processing Failure):**
    1.  **Backend:** The assessment worker fails during processing.
    2.  **Backend:** The worker updates the document's status in the database to `ERROR` and may log specific error details.
    3.  **Frontend (Polling):** `fetchDocuments(true)` retrieves the `ERROR` status. Specific error messages, if provided by the API, might be stored in `assessmentErrors` and displayed.
    4.  **UI Display:** The status shows "ERROR". A "Retry" action usually becomes available.
*   **Process Flow (Successful User-Initiated Cancellation via `handleCancelAssessment`):**
    1.  **User Action:** Clicks the "Cancel" button for a `PROCESSING` document.
    2.  **Frontend:** The `handleCancelAssessment` function sends a cancellation request to the backend.
    3.  **Backend:** Successfully processes the cancellation request and responds affirmatively.
    4.  **Frontend (Local Update):** Upon receiving a successful cancellation response, the frontend *itself* updates the document's status to `ERROR_STATUS` within its local `documents` state. This is an optimistic update to reflect that the task is no longer active and is considered an error/aborted state from the user's perspective of a completed assessment.
    5.  **UI Display:** The status changes to "ERROR".

## 6. `LIMIT_EXCEEDED`

*   **Description:** The document exceeded a predefined processing limit (e.g., word count, file size) and could not be fully processed.
*   **Triggered By:**
    *   The backend assessment worker determines during analysis that the document breaches a configured processing limit.
*   **Process Flow:**
    1.  **Backend:** The assessment worker detects the limit breach.
    2.  **Backend:** The worker updates the document's status in the database to `LIMIT_EXCEEDED`.
    3.  **Frontend (Polling):** `fetchDocuments(true)` retrieves this new status.
    4.  **UI Display:** The status shows "LIMIT_EXCEEDED". A "Retry" action is typically available, though it might encounter the same limit if the document hasn't changed.

---

## Transient UI States (Not persistent backend statuses, but UI representations)

These are states shown temporarily in the UI based on ongoing actions or frontend-detected issues during an action.

### "Cancelling..." (UI Badge)

*   **Description:** Displayed in the status column while the frontend is waiting for a response from the backend after a user initiates an assessment cancellation.
*   **Triggered By:** User clicks the "Cancel" button on a document with the `PROCESSING` status.
*   **Process Flow:**
    1.  **Frontend (`handleCancelAssessment`):** This function is called.
    2.  **Frontend State:** It sets a loading state for cancellation for that specific document (e.g., `cancellingStatus[doc.id] = 'loading'`).
    3.  **UI Display:** The `statusBadge` logic detects this loading state and displays "Cancelling..." along with a spinner icon. This persists until the API call to the backend returns.

### "Cancel Failed" (UI Badge)

*   **Description:** Displayed in the status column if the frontend's API call to cancel an assessment fails.
*   **Triggered By:** The API request made by `handleCancelAssessment` (e.g., to `/documents/{id}/cancel-assessment`) fails due to a network issue or an error response from the backend.
*   **Process Flow:**
    1.  **Frontend (`handleCancelAssessment`):** The API call to the backend fails.
    2.  **Frontend Error Handling:** The `catch` block or error handling logic within `handleCancelAssessment` is executed. An error message is typically stored in the component's state (e.g., `assessmentErrors[doc.id]`).
    3.  **UI Display:** The `statusBadge` logic checks for this error state and, if present after a cancellation attempt, displays "Cancel Failed". The document's actual status in the backend (likely still `PROCESSING` if the cancellation command itself failed) might remain unchanged.

# Document Processing and Usage Limit Enforcement Workflow

This document outlines the process by which documents are assessed for AI-generated content and how usage limits (based on word and character counts) are applied according to the teacher's subscription plan.

## 1. Document Upload and Queuing

1.  **Upload:** A teacher uploads a document through the frontend interface.
2.  **Initial Save:** The document metadata (filename, file type, associated teacher, etc.) is saved in the database with an initial status (e.g., `UPLOADED`). The document file itself is stored in blob storage.
3.  **Task Creation:** An assessment task is created and added to a processing queue. This task contains information like the document ID and the teacher's ID.

## 2. Assessment Worker Processing

The `AssessmentWorker` is a backend process that continuously polls the queue for new tasks. When a task is claimed:

1.  **Document Retrieval:** The worker retrieves the full document details from the database using the document ID from the task.
2.  **Status Update (Processing):** The document's status is updated to `PROCESSING` in the database. An associated `Result` record is also created/updated to `PROCESSING`.

3.  **Text Extraction & Counting:**
    *   The document file is downloaded from blob storage.
    *   Text content is extracted from the document.
    *   The **`character_count`** and **`word_count`** for the current document are calculated based on the extracted text.

4.  **Update Document Counts:**
    *   The calculated `character_count` and `word_count` are immediately saved to the document's record in the database. This ensures these counts are persisted even if subsequent steps fail.

5.  **Usage Limit Check:**
    *   **Fetch Teacher's Plan:** The worker retrieves the teacher's current subscription plan (e.g., Free, Pro, Schools).
    *   **Schools Plan Bypass:** If the teacher is on a "Schools" plan (or a similar unlimited tier), the usage limit check is bypassed, and processing proceeds directly to ML analysis.
    *   **Fetch Current Usage:** For metered plans (Free, Pro), the worker calls `crud.get_usage_stats_for_period` to get the teacher's current total `word_count` and `character_count` for the current billing period (e.g., monthly).
        *   **Important:** This usage statistic now correctly includes the word and character counts from all previously processed documents, **including those that have been soft-deleted** but were assessed before deletion (i.e., have a `word_count` and `status` like `COMPLETED`).
    *   **Calculate Projected Usage:** The worker calculates the teacher's *projected* usage if the current document were to be processed:
        *   `projected_words = current_monthly_words + current_document_word_count`
        *   `projected_chars = current_monthly_chars + current_document_character_count`
    *   **Compare with Plan Limits:** The `projected_words` and `projected_chars` are compared against the limits defined for the teacher's current subscription plan (e.g., `FREE_PLAN_MONTHLY_WORD_LIMIT`).

6.  **Outcome of Limit Check:**

    *   **A. Limit Exceeded:**
        *   If `projected_words` or `projected_chars` exceed the plan's limits:
            *   The document's status is updated to `LIMIT_EXCEEDED`.
            *   The associated `Result` record status is updated to `FAILED`, and an error message indicating the limit type (word or character) is stored.
            *   **No ML API Call:** The document is **not** sent for AI content analysis.
            *   The assessment task is removed from the queue.
            *   Processing for this document stops.

    *   **B. Within Limits:**
        *   If `projected_words` and `projected_chars` are within the plan's limits:
            *   **ML API Call:** The extracted text is sent to the AI detection ML endpoint.
            *   **Process ML Response:** The response from the ML API (containing scores, classifications, etc.) is processed.
            *   **Update Document (Completed):** The document's status is updated to `COMPLETED`, and the overall AI score is saved directly on the document record.
            *   **Update Result (Completed):** The `Result` record is updated to `COMPLETED` with the detailed assessment (overall score, paragraph-level analysis, AI-generated label, etc.).
            *   The assessment task is removed from the queue.

## Summary of Key Logic for Usage Limits:

*   Word and character counts are determined **before** any ML processing.
*   The system checks if processing the **current document** will cause the user to exceed their quota.
*   Usage statistics accurately reflect counts from **all previously processed documents, including soft-deleted ones** that had their words/chars counted.
*   If a document would push a user over their limit, its status is set to `LIMIT_EXCEEDED`, and it is **not** sent for ML analysis.